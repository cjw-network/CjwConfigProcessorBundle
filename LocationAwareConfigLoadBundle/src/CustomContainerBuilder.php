<?php


namespace App\CJW\LocationAwareConfigLoadBundle\src;


use Exception;
use ReflectionClass;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

/**
 * Class CustomContainerBuilder is a ContainerBuilder which possesses functionality to keep track of the file paths
 * being loaded and parsed in order to keep track of the origin of the loaded parameters.
 *
 * @package App\CJW\LocationAwareConfigLoadBundle\src
 */
class CustomContainerBuilder extends ContainerBuilder
{
// region unrequired previous variables
//    /** @var string Stores the path of the currently parsed file */
//    private $currentLocation;
//
//    /** @var array Stores the parameter names as keys and the pushes the location they appear in, into an array */
//    private $paramFromLocations;
// endregion

    private $isBundleConfigMode;

    public function __construct(ParameterBagInterface $parameterBag = null)
    {
        // Provide the container with a custom ParameterBag in order to allow location awareness.
        parent::__construct(new LocationAwareParameterBag());
        $this->isBundleConfigMode = false;
    }

    /**
     * Sets the current location to the location string given to the function.
     *
     * @param string $location The location to be set.
     */
    public function setCurrentLocation(string $location) {

        /** The parameterBag is the custom one created to feature such a function */
        $this->parameterBag->setCurrentLocation($location);
    }

// region earlier tries
//    public function prependExtensionConfig(string $name, array $config)
//    {
//        $this->setCurrentLocation($name."-bundle");
//        parent::prependExtensionConfig($name, $config); // TODO: Change the autogenerated stub
//    }
//
//    public function merge(ContainerBuilder $container)
//    {
//        if ($container instanceof MergeExtensionConfigurationContainerBuilder) {
//            $extension = $container->classReflectors[0]?? null;
//
//            if ($extension instanceof ReflectionClass) {
//                $path = $extension->getFileName()?? "bundle";
//                $this->setCurrentLocation($path);
//            }
//        }
//        parent::merge($container); // TODO: Change the autogenerated stub
//    }

//    public function loadFromExtension(string $extension, array $values = null)
//    {
//        parent::loadFromExtension($extension, $values); // TODO: Change the autogenerated stub
//        $this->parameterBag->setBundleConfigWithPath($extension,$values);
//        return $this;
//    }
// endregion

    /**
     * @override
     */
    public function compile(bool $resolveEnvPlaceholders = false)
    {
        // prior to the compilation starting, set the current location to a blanket "bundles", so that if no other paths can be found, it is at least
        // known, that the parameters come from the bundle process.
        $this->setCurrentLocation("Bundles");
        CustomValueStorage::activateBundleConfigMode(true);
        try {
            parent::compile($resolveEnvPlaceholders);
        } catch (Exception $error) {
        }
    }

//    /**
//     * @param LocationAwareParameterBag $originalBag
//     */
//    public function restoreParameterBagToPreCustomCompile(LocationAwareParameterBag $originalBag) {
//        $this->parameterBag = $originalBag;
//    }

    /**
     * {@override}
     * This is an extension of the function which only adds that the bundle names are being given to the LocationAwareParameterBag.
     *
     * @param string $name The name of the bundle who's extension config to retrieve.
     * @return array Returns the found configuration.
     */
    public function getExtensionConfig(string $name)
    {
        try {
            // Get the class of the extension, then generate a Reflection class out of that, which allows finding the path to the file, then set that path
            $extensionClass = get_class($this->getExtension($name));
            $extensionReflector = new ReflectionClass($extensionClass);
            $extensionLocation = $extensionReflector->getFileName();
            $this->setCurrentLocation($extensionLocation);

            // Following the Symfony-Bundle-Conventions, the config directory of the bundles are being set instead of the extension class
            $extensionLocation = ConfigPathUtility::convertExtensionPathToConfigDirectory($extensionLocation);
            if ($extensionLocation && is_string($extensionLocation)) {
                ConfigPathUtility::addPathToPathlist($extensionLocation);
            }
        } catch (Exception $error) {
            // In the event that something fails in the above procedure to determine the correct paths, just take the name of the extension as a path
            $this->setCurrentLocation($name);
        }

        // continue the typical, normal extension-config-functionality
        return parent::getExtensionConfig($name);
    }

    /**
     * @override
     * This override ensures, that no definition of a service will be added while loading the config files of the bundles
     * outside of the bundle configuration phase.
     */
    public function addDefinitions(array $definitions)
    {
        if (!$this->isBundleConfigMode) {
            parent::addDefinitions($definitions); // TODO: Change the autogenerated stub
        }
    }

    /**
     * @override
     * This override ensures, that no service will be registered while loading the config files of the bundles
     * outside of the bundle configuration phase.
     */
    public function register(string $id, string $class = null)
    {
        if (!$this->isBundleConfigMode) {
            return parent::register($id, $class); // TODO: Change the autogenerated stub
        }

        return null;
    }

    /**
     * @override
     * This override ensures, that no service definition will be added while loading the config files of the bundles
     * outside of the bundle configuration phase.
     */
    public function setDefinition(string $id, Definition $definition)
    {
        if (!$this->isBundleConfigMode) {
            return parent::setDefinition($id, $definition); // TODO: Change the autogenerated stub
        }

        return null;
    }

    /**
     * @override
     * This override ensures, that no service alias will be set while loading the config files of the bundles
     * outside of the bundle configuration phase.
     */
    public function setAlias(string $alias, $id)
    {
        if (!$this->isBundleConfigMode) {
            return parent::setAlias($alias, $id); // TODO: Change the autogenerated stub
        }

        return null;
    }

    /**
     * @override
     * This override ensures, that no service definition will be registered while loading the config files of the bundles
     * outside of the bundle configuration phase.
     */
    public function setDefinitions(array $definitions)
    {
        if (!$this->isBundleConfigMode) {
            parent::setDefinitions($definitions); // TODO: Change the autogenerated stub
        }
    }

    /**
     * Dictates whether bundle config paths are being loaded outside of the bundle configuration part of the
     * config load process (namely the {@see MergeExtensionConfigurationPass}).
     *
     * @param bool $isBundleConfigMode A boolean which sets the bundleConfigMode either to true or false (if set to true, no services will be registered to the container).
     */
    public function setIsBundleConfigMode(bool $isBundleConfigMode): void
    {
        $this->isBundleConfigMode = $isBundleConfigMode;
    }

// region more tries
//    public function getParameterBag()
//    {
//        $this->paramFromLocations = $this->parameterBag->getParamLocation();
//        return parent::getParameterBag(); // TODO: Change the autogenerated stub
//    }
//
//    public function merge(ContainerBuilder $container)
//    {
//        parent::merge($container); // TODO: Change the autogenerated stub
//        $this->parameterBag->overrideParameters($this->paramFromLocations);
//    }

//    public function setParameter(string $name, $value)
//    {
//        parent::setParameter($name, $value); // TODO: Change the autogenerated stub
//
//        if (key_exists($name, $this->paramFromLocations)) {
//            $this->paramFromLocations[$name][$this->currentLocation] = $value;
//        } else {
//            $this->paramFromLocations[$name] = [$this->currentLocation => $value];
//        }
//    }
// endregion
}
